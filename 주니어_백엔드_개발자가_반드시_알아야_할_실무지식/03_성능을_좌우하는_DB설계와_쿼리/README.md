## 성능 핵심 DB
DB 성능은 연동하는 모든 서버에 영향을 미친다. 때문에 대부분의 성능 최적화 작업은 DB 성능 최적화 작업과 연관되어 있다. <br/>
또한 대부분의 애플리케이션은 읽기 작업이 쓰기 작업보다 많기 때문에 읽기 성능 최적화 작업이 중요하다. <br/>
DB의 읽기 성능 최적화 작업의 핵심은 **_인덱스 생성 및 인덱스를 최대한 활용하는 것_**이다. 인덱스를 설정하지 않으면 테이블 풀 스캔을 하게되어 성능 저하가 발생할 수 있다. 또한 인덱스를 생성하였지만 잘못된 기준으로 인덱스를 생성하거나, 적절하지 않은 쿼리 작성으로 인해서 인덱스를 활용하지 못하는 경우도 많다. <br/>
만약 인덱스 생성 및 쿼리 최적화 작업을 통해서도 성능 향상이 되지 않는다면, 다음과 같은 방법들을 고려할 수 잇다. 
- 데이터베이스 스펙업을 통한 성능 향상
- 읽기 성능을 향상시키기 위한 복제 DB 도입
- 데이터베이스 설정 최적화
- 읽기 성능을 향상시키기 위한 캐시 도입
- 대기열 기반의 쓰기 지연 처리
- 읽기와 쓰기를 분리하기 위한 CQRS 패턴 도입

## 인덱스
인덱스란 데이터베이스 테이블의 특정 컬럼에 대한 검색 속도를 향상시키기 위한 자료 구조이다. <br/>
인덱스는 책의 목차와 유사한 역할을 하며, 특정 컬럼의 값을 기준으로 데이터를 빠르게 찾을 수 있도록 도와준다. <br/>


### 인덱스의 선정 기준

#### 1. 조회 활용도가 높은 컬럼
기본적으로 인덱스는 읽기 성능을 향상시키 위해서 사용되는 것이기 때문에, 인덱스 생성 기준의 가장 첫번째로 고려되어야 하는 것은 조회 활용도가 높은 컬럼이다. <br/>
조회 활용도가 높은 컬럼이란, `WHERE, JOIN, ORDER BY, GROUP BY`절 등에 자주 사용되는 컬럼을 의미한다.<br/>
- WHERE, JOIN: 인덱스를 사용하여 조건에 맞는 데이터를 빠르게 찾을 수 있음
- ORDER BY: 인덱스를 사용하여 정렬 작업을 빠르게 수행할 수 있음
- GROUP BY: 인덱스를 사용하여 그룹화 작업을 빠르게 수행할 수 있음

인덱스는 조회 성능을 향상시키지만 쓰기 성능 및 저장 공간에 영향을 미치기 때문에, 모든 컬럼에 인덱스를 생성하는 것은 바람직하지 않다. 때문에 단순히 조회 속도를 높이기 위해서 인덱스를 생성하기 보다는, 조회 활용도가 높은 컬럼을 우선적으로 인덱스 생성 대상으로 선정하는 것이 좋다. <br/>

#### 2. 카디널리티(Cardinality)가 높은 컬럼
카디널리티란(Cardinality, 기수성)이란 **_특정 데이터의 유니크한 값의 개수_**를 의미한다. <br/>
예를 들어서 1,000건의 데이터가 존재하는 테이블에서 성별(남/여) 컬럼이 있다고 가정할 때, 해당 컬럼은 2개의 유니크한 값을 가지기 때문에 카디널리티가 낮다. 만약 성별 컬럼을 인덱스로 생성하여 조회에 활용하게 되면 인덱스 스캔의 효율성이 떨어지게 된다. 때문에 조회활용도가 높다고 하여, 카디널리티가 낮은 컬럼을 인덱스 대상으로 선정하는 것은 다시 한번 생각해볼 문제다. <br/>
```sql
-- user 테이블에 전체 레코드 수는 1,000 건이 존재한다고 가정하고, gender = `M`의 레코드 수가 500, gender = `F`의 레코드 수가 500 건이라고 가정

-- 각 쿼리는 인덱스를 통해서 500건의 데이터를 스캔
select * from user where gender = 'M';
select * from user where gender = 'F';
```
해당 쿼리를 실행하게 되면, 인덱스를 통해서 실제 레코드를 찾기 위해서 500건의 데이터를 스캔해야 한다. 때문에 인덱스를 사용하는 것보다, 테이블 풀 스캔을 통해서 1,000건의 데이터를 스캔하는 것이 더 효율적일 수 있다. <br/>
> 참고로 DBMS 옵티마이저는 인덱스를 스캔 효율성이 떨어진다고 판단되면, 테이블 풀 스캔을 선택하는 경우도 있다. <br/>

카디널리티가 낮다고 하여 무조건 인덱스 생성 대상에서 제외하는 것은 바람직하지 않다. 카디널리티가 낮더라도 선택도가 높은 컬럼이거나, 레코드의 직접 접근하지 않고 인덱스내에서만 처리가 가능한 커버링 인덱스의 경우에는 인덱스 생성 대상이 될 수 있다. <br/>

#### 3. 고유한 값의 비율이 낮은 컬럼
**_특정 컬럼의 고유한 값의 비율(조건에 맞는 레코드 수/전체 레코드 수)이 낮을 수록_** 인덱스 스캔의 효율성이 높아지기 때문에 인덱스 생성 대상이 될 수 있다. <br/>
예를 들어 대기열 테이블에 10,000건의 데이터가 존재한다고 가정할때, 대기열 상태 컬럼이 `대기 (100건), 진행중(9,000건), 완료(900건)` 3개의 상태로 구성되어 있으면 각 상태의 비율은 각각 `대기(0.01), 진행중(0.9), 완료(0.09)`가 된다. 대기열 상태 컬럼의 경우 카디널리티는 낮지만, 만약 `대기` 상태의 레코드를 조회하는 쿼리가 자주 실행된다면 인덱스 스캔 효율성이 높아지기 때문에 인덱스 생성 대상이 될 수 있다. <br/>

#### 4. 수정 빈도가 낮은 컬럼
인덱스는 B-Tree 구조로 되어 있기 때문에, 인덱스가 생성된 컬럼의 데이터가 수정될 때마다 인덱스도 함께 수정되어야 한다. 때문에 수정 빈도가 높은 컬럼에 인덱스를 생성하게 되면, 인덱스 수정 작업으로 인해서 오히려 성능 저하가 발생할 수 있다. <br/>
예를 들어서 조회 활용도가 낮고 수정 빈도가 높은 컬럼에 인덱스를 생성하게 되면, 인덱스 수정 작업이 빈번하게 발생하여 성능 저하가 발생할 수 있다. 

### 인덱스를 활용하지 못하는 경우
조회 성능을 향상시키기 위해서 인덱스를 생성하였지만, 잘못된 쿼리 작성으로 인해서 인덱스를 활용하지 못하는 경우가 있다. 때문에 인덱스를 생성한 후에도 실제 쿼리에서 인덱스가 활용되고 있는지 확인하는 것이 중요하다. <br/>

#### LIKE 절의 접두사/부분 일치 검색
LIKE는 와일드카드(%)를 사용하여 문자열을 검색하는데 활용하며 주로 키워드를 검색할때 사용된다. 하지만 LIKE 검색에서 와일드카드가 문자열의 앞에 위치하는 경우(접두사 검색, 부분 일치 검색)에는 인덱스를 활용하지 못한다. <br/>
이는 B-Tree 인덱스의 특성 때문인데, B-Tree 인덱스는 문자열의 시작 부분부터 정렬되어 있기 때문에, 접두사 검색에서는 인덱스를 활용할 수 있지만, 접미사 검색이나 부분 일치 검색에서는 인덱스를 활용할 수 없다. <br/>
```sql
-- product_name 컬럼에 인덱스 생성
CREATE INDEX idx_product_name ON products (product_name);

-- 인덱스를 활용하는 경우
SELECT * FROM products WHERE product_name LIKE 'Apple%';

-- 인덱스를 활용못하는 경우
SELECT * FROM products WHERE product_name LIKE '%Apple%';
SELECT * FROM products WHERE product_name LIKE '%Apple';
```
이를 해결하기 위해서는 다음과 같은 방법들을 고려할 수 있다.
- FULLTEXT 인덱스 활용: 일부 RDBMS에서는 FULLTEXT 인덱스를 지원하며, 이를 활용하여 접두사/부분 일치 검색을 효율적으로 처리할 수 있다.
- 검색 엔진 도입: Elasticsearch, Opensearch, MongoDB Atlas Search와 같은 전문 검색 엔진을 도입하여 복잡한 문자열 검색을 처리할 수 있다.

#### 복합 인덱스의 선두 컬럼 미사용
복합 인덱스는 여러 컬럼을 조합하여 생성된 선두 컬럼이 활용되는 경우에는 인덱스를 활용할 수 있지만, 선두 컬럼이 활용되지 않는 경우에는 인덱스를 활용하지 못한다. <br/>
이는 B-Tree 인덱스의 특성 때문인데, 복합 인덱스는 선두 컬럼부터 정렬되어 있기 때문에, 선두 컬럼이 활용되지 않는 경우에는 인덱스를 활용할 수 없다. <br/>
```sql
-- category, price 컬럼에 복합 인덱스 생성
CREATE INDEX idx_category_price ON products (category, price)

-- 인덱스를 활용하는 경우
SELECT * FROM products WHERE category = 'RDBMS' AND price < 1000;
SELECT * FROM products WHERE category = 'RDBMS';

-- 인덱스를 활용하지 못하는 경우
SELECT * FROM products WHERE price < 1000;
```
이를 해결하기 위해서는 다음과 같은 방법들을 고려할 수 있다.
- 쿼리 수정: 선두 컬럼이 활용되도록 쿼리를 수정할 수 있다.
- 복합 인덱스 재설계: 쿼리에서 자주 사용되는 컬럼 순서에 맞게 복합 인덱스를 재설계할 수 있다.
- 단일 컬럼 인덱스 추가 생성: 선두 컬럼이 아닌 컬럼에 대해서도 단일 컬럼 인덱스를 추가로 생성하여 조회에 활용할 수 있다.

#### 부정형 조건 사용

#### OR 조건 사용

#### 인덱스 컬럼 함수 사용 및 가공
인덱스를 생성한 컬럼에 함수나 연산자를 사용하여 가공하는 경우, 인덱스의 값을 직접 참조할 수 없기 때문에 인덱스를 활용하지 못한다. <br/>
인덱스는 원본 데이터의 값을 기준으로 생성되고 조회되기 때문에 가공된 값은 인덱스에서 찾을 수 없다. <br/>
```sql
-- product_name 컬럼에 인덱스 생성
CREATE INDEX idx_product_name ON products (product_name);
CREATE INDEX idx_avg_rating ON products (avg_rating);

-- 인덱스를 활용하지 못하는 경우
SELECT * FROM products WHERE UPPER(product_name) = 'APPLE';
SELECT * FROM products WHERE avg_rating * 100 >= 4;
```
때문에 인덱스 컬럼을 가공하는 대신에 다음과 같은 방법들을 고려할 수 있다.
- 가공된 값을 저장하는 별도의 컬럼 생성: 가공된 값을 미리 저장하는 별도의 컬럼을 생성하고, 해당 컬럼에 인덱스를 생성하여 조회에 활용할 수 있다. 
  - 예를 들어, `UPPER(product_name)` 값을 저장하는 `upper_product_name` 컬럼을 생성하고, 해당 컬럼에 인덱스를 생성할 수 있다.
- 함수 기반 인덱스(Function-Based Index) 활용: 일부 RDBMS에서는 함수 기반 인덱스를 지원하며, 이를 활용하여 함수로 가공된 값에 대한 인덱스를 생성할 수 있다.
  - 예를 들어, Oracle에서는 `CREATE INDEX idx_upper_product_name ON products (UPPER(product_name));`와 같이 함수 기반 인덱스를 생성할 수 있다.
- 인덱스 컬럼 미가공: 가능하다면 인덱스 컬럼을 가공하지 않고 원본 값을 그대로 사용하는 쿼리로 변경할 수 있다.
  - 예를 들어, `avg_rating * 100 >= 4` 대신에 `avg_rating >= 0.04`로 변경할 수 있다.

#### 인덱스 명시적/암묵적 타입 변환
인덱스 컬럼 가공과 유사하게 명시적/암묵적 타입 변환이 발생하는 경우에도 인덱스를 활용하지 못한다. <br/>
명시적 타입 변환은 CAST, CONVERT 함수를 사용하여 데이터 타입을 변환하는 경우를 의미하며, 암묵적 타입 변환은 서로 다른 데이터 타입 간의 비교 연산이 발생하는 경우 RDBMS가 자동으로 타입을 변환하는 경우를 의미하다. 이는 인덱스가 생성된 데이터 타입과 조회 시 사용되는 데이터 타입이 일치하지 않기 때문에 인덱스를 활용하지 못한다. 마치 타입언어에서 엄격한 타입 검사를 하는 것과 유사하다. <br/>

```sql
-- products 테이블의 product_id 컬럼에 인덱스 생성, product_id 컬럼이 정수형(INT)이라고 가정
CREATE INDEX idx_product_id ON products (product_id);
-- product_stock 테이블의 product_id 컬럼에 인덱스 생성, product_id 컬럼이 문자열형(CHAR)이라고 가정
CREATE INDEX idx_orders ON product_stock (product_id);

-- 인덱스를 활용하지 못하는 경우 (명시적 타입 변환)
SELECT * FROM products WHERE CAST(product_id AS CHAR) = '1001';

-- 인덱스를 활용하지 못하는 경우 (암묵적 타입 변환)
SELECT * FROM products WHERE product_id = '1001';
SELECT * FROM products JOIN product_stock ON product_stock.product_id = products.product_id;
```



## 다른 성능 최적화 방법들

#### 역정규화를 통한 집계 성능 향상
- 

#### 조회 범위 축소하기 

#### 서브쿼리 대신 조인 사용하기

#### 애플리케이션에서 데이터 조인하기

#### 오프셋 기반 페이징 처리 대신 커서 기반 페이징 처리 사용하기

#### Count 쿼리 최적화 하기



#### 오래된 데이터 아카이빙 하기
