## 성능 핵심 DB
DB 성능은 연동하는 모든 서버에 영향을 미친다. 때문에 대부분의 성능 최적화 작업은 DB 성능 최적화 작업과 연관되어 있다. <br/>
또한 대부분의 애플리케이션은 읽기 작업이 쓰기 작업보다 많기 때문에 읽기 성능 최적화 작업이 중요하다. <br/>
DB의 읽기 성능 최적화 작업의 핵심은 **_인덱스 생성 및 인덱스를 최대한 활용하는 것_**이다. 인덱스를 설정하지 않으면 테이블 풀 스캔을 하게되어 성능 저하가 발생할 수 있다. 또한 인덱스를 생성하였지만 잘못된 기준으로 인덱스를 생성하거나, 적절하지 않은 쿼리 작성으로 인해서 인덱스를 활용하지 못하는 경우도 많다. <br/>
만약 인덱스 생성 및 쿼리 최적화 작업을 통해서도 성능 향상이 되지 않는다면, 다음과 같은 방법들을 고려할 수 잇다. 
- 데이터베이스 스펙업을 통한 성능 향상
- 읽기 성능을 향상시키기 위한 복제 DB 도입
- 데이터베이스 설정 최적화
- 읽기 성능을 향상시키기 위한 캐시 도입
- 대기열 기반의 쓰기 지연 처리
- 읽기와 쓰기를 분리하기 위한 CQRS 패턴 도입

## 인덱스
인덱스란 데이터베이스 테이블의 특정 컬럼에 대한 검색 속도를 향상시키기 위한 자료 구조이다. <br/>
인덱스는 책의 목차와 유사한 역할을 하며, 특정 컬럼의 값을 기준으로 데이터를 빠르게 찾을 수 있도록 도와준다. <br/>


### 인덱스의 선정 기준

#### 1. 조회 활용도가 높은 컬럼
기본적으로 인덱스는 읽기 성능을 향상시키 위해서 사용되는 것이기 때문에, 인덱스 생성 기준의 가장 첫번째로 고려되어야 하는 것은 조회 활용도가 높은 컬럼이다. <br/>
조회 활용도가 높은 컬럼이란, `WHERE, JOIN, ORDER BY, GROUP BY`절 등에 자주 사용되는 컬럼을 의미한다.<br/>
- WHERE, JOIN: 인덱스를 사용하여 조건에 맞는 데이터를 빠르게 찾을 수 있음
- ORDER BY: 인덱스를 사용하여 정렬 작업을 빠르게 수행할 수 있음
- GROUP BY: 인덱스를 사용하여 그룹화 작업을 빠르게 수행할 수 있음

인덱스는 조회 성능을 향상시키지만 쓰기 성능 및 저장 공간에 영향을 미치기 때문에, 모든 컬럼에 인덱스를 생성하는 것은 바람직하지 않다. 때문에 단순히 조회 속도를 높이기 위해서 인덱스를 생성하기 보다는, 조회 활용도가 높은 컬럼을 우선적으로 인덱스 생성 대상으로 선정하는 것이 좋다. <br/>

#### 2. 카디널리티(Cardinality)가 높은 컬럼
카디널리티란(Cardinality, 기수성)이란 **_특정 데이터의 유니크한 값의 개수_**를 의미한다. <br/>
예를 들어서 1,000건의 데이터가 존재하는 테이블에서 성별(남/여) 컬럼이 있다고 가정할 때, 해당 컬럼은 2개의 유니크한 값을 가지기 때문에 카디널리티가 낮다. 만약 성별 컬럼을 인덱스로 생성하여 조회에 활용하게 되면 인덱스 스캔의 효율성이 떨어지게 된다. 때문에 조회활용도가 높다고 하여, 카디널리티가 낮은 컬럼을 인덱스 대상으로 선정하는 것은 다시 한번 생각해볼 문제다. <br/>
```sql
-- user 테이블에 전체 레코드 수는 1,000 건이 존재한다고 가정하고, gender = `M`의 레코드 수가 500, gender = `F`의 레코드 수가 500 건이라고 가정

-- 각 쿼리는 인덱스를 통해서 500건의 데이터를 스캔
select * from user where gender = 'M';
select * from user where gender = 'F';
```
해당 쿼리를 실행하게 되면, 인덱스를 통해서 실제 레코드를 찾기 위해서 500건의 데이터를 스캔해야 한다. 때문에 인덱스를 사용하는 것보다, 테이블 풀 스캔을 통해서 1,000건의 데이터를 스캔하는 것이 더 효율적일 수 있다. <br/>
> 참고로 DBMS 옵티마이저는 인덱스를 스캔 효율성이 떨어진다고 판단되면, 테이블 풀 스캔을 선택하는 경우도 있다. <br/>

카디널리티가 낮다고 하여 무조건 인덱스 생성 대상에서 제외하는 것은 바람직하지 않다. 카디널리티가 낮더라도 선택도가 높은 컬럼이거나, 레코드의 직접 접근하지 않고 인덱스내에서만 처리가 가능한 커버링 인덱스의 경우에는 인덱스 생성 대상이 될 수 있다. <br/>

#### 3. 고유한 값의 비율이 낮은 컬럼
**_특정 컬럼의 고유한 값의 비율(조건에 맞는 레코드 수/전체 레코드 수)이 낮을 수록_** 인덱스 스캔의 효율성이 높아지기 때문에 인덱스 생성 대상이 될 수 있다. <br/>
예를 들어 대기열 테이블에 10,000건의 데이터가 존재한다고 가정할때, 대기열 상태 컬럼이 `대기 (100건), 진행중(9,000건), 완료(900건)` 3개의 상태로 구성되어 있으면 각 상태의 비율은 각각 `대기(0.01), 진행중(0.9), 완료(0.09)`가 된다. 대기열 상태 컬럼의 경우 카디널리티는 낮지만, 만약 `대기` 상태의 레코드를 조회하는 쿼리가 자주 실행된다면 인덱스 스캔 효율성이 높아지기 때문에 인덱스 생성 대상이 될 수 있다. <br/>

#### 4. 수정 빈도가 낮은 컬럼
인덱스는 B-Tree 구조로 되어 있기 때문에, 인덱스가 생성된 컬럼의 데이터가 수정될 때마다 인덱스도 함께 수정되어야 한다. 때문에 수정 빈도가 높은 컬럼에 인덱스를 생성하게 되면, 인덱스 수정 작업으로 인해서 오히려 성능 저하가 발생할 수 있다. <br/>
예를 들어서 조회 활용도가 낮고 수정 빈도가 높은 컬럼에 인덱스를 생성하게 되면, 인덱스 수정 작업이 빈번하게 발생하여 성능 저하가 발생할 수 있다. 

### 인덱스를 활용하지 못하는 경우
조회 성능을 향상시키기 위해서 인덱스를 생성하였지만, 잘못된 쿼리 작성으로 인해서 인덱스를 활용하지 못하는 경우가 있다. 때문에 인덱스를 생성한 후에도 실제 쿼리에서 인덱스가 활용되고 있는지 확인하는 것이 중요하다. <br/>

#### LIKE 절의 접두사/부분 일치 검색
LIKE는 와일드카드(%)를 사용하여 문자열을 검색하는데 활용하며 주로 키워드를 검색할때 사용된다. 하지만 LIKE 검색에서 와일드카드가 문자열의 앞에 위치하는 경우(접두사 검색, 부분 일치 검색)에는 인덱스를 활용하지 못한다. <br/>
이는 B-Tree 인덱스의 특성 때문인데, B-Tree 인덱스는 문자열의 시작 부분부터 정렬되어 있기 때문에, 접두사 검색에서는 인덱스를 활용할 수 있지만, 접미사 검색이나 부분 일치 검색에서는 인덱스를 활용할 수 없다. <br/>
```sql
-- product_name 컬럼에 인덱스 생성
CREATE INDEX idx_product_name ON products (product_name);

-- 인덱스를 활용하는 경우
SELECT * FROM products WHERE product_name LIKE 'Apple%';

-- 인덱스를 활용못하는 경우
SELECT * FROM products WHERE product_name LIKE '%Apple%';
SELECT * FROM products WHERE product_name LIKE '%Apple';
```
이를 해결하기 위해서는 다음과 같은 방법들을 고려할 수 있다.
- FULLTEXT 인덱스 활용: 일부 RDBMS에서는 FULLTEXT 인덱스를 지원하며, 이를 활용하여 접두사/부분 일치 검색을 효율적으로 처리할 수 있다.
- 검색 엔진 도입: Elasticsearch, Opensearch, MongoDB Atlas Search와 같은 전문 검색 엔진을 도입하여 복잡한 문자열 검색을 처리할 수 있다.

#### 복합 인덱스의 선두 컬럼 미사용
복합 인덱스는 여러 컬럼을 조합하여 생성된 선두 컬럼이 활용되는 경우에는 인덱스를 활용할 수 있지만, 선두 컬럼이 활용되지 않는 경우에는 인덱스를 활용하지 못한다. <br/>
이는 B-Tree 인덱스의 특성 때문인데, 복합 인덱스는 선두 컬럼부터 정렬되어 있기 때문에, 선두 컬럼이 활용되지 않는 경우에는 인덱스를 활용할 수 없다. <br/>
```sql
-- category, price 컬럼에 복합 인덱스 생성
CREATE INDEX idx_category_price ON products (category, price)

-- 인덱스를 활용하는 경우
SELECT * FROM products WHERE category = 'RDBMS' AND price < 1000;
SELECT * FROM products WHERE category = 'RDBMS';

-- 인덱스를 활용하지 못하는 경우
SELECT * FROM products WHERE price < 1000;
```
이를 해결하기 위해서는 다음과 같은 방법들을 고려할 수 있다.
- 쿼리 수정: 선두 컬럼이 활용되도록 쿼리를 수정할 수 있다.
- 복합 인덱스 재설계: 쿼리에서 자주 사용되는 컬럼 순서에 맞게 복합 인덱스를 재설계할 수 있다.
- 단일 컬럼 인덱스 추가 생성: 선두 컬럼이 아닌 컬럼에 대해서도 단일 컬럼 인덱스를 추가로 생성하여 조회에 활용할 수 있다.

#### 부정형 조건 사용
부정형 조건(NOT, !=, <>, IS NOT NULL 등)을 사용하는 경우, 인덱스 사용이 불가하다. <br/>
인덱스는 어디에 데이터가 존재하는지 빠르게 찾기 위한 자료구조이지, 특정 조건에 맞지 않는 데이터를 찾기 위한 자료구조가 아니기 때문이다. <br/>
인덱스는 정렬과 연속성을 기반으로 인덱스 스캔이 이루어지며, 부정형 조건은 어디에 데이터가 존재하지 않는지를 찾아야하기 때문에 연속성을 활용할 수 없다. <br/>
```sql
-- status 컬럼에 인덱스 생성
CREATE INDEX idx_status ON orders (status);  

SELECT * FROM orders WHERE status != 'COMPLETED';
```
이를 해결하기 위해서는 다음과 같은 방법들을 고려할 수 있다.
- 긍정형 조건 사용: 가능하다면 부정형 조건 대신에 긍정형 조건을 사용하여 쿼리를 작성할 수 있다.
  - 예를 들어, `status != 'COMPLETED'` 대신에 `status IN ('PENDING', 'PROCESSING', 'CANCELLED')`와 같이 긍정형 조건으로 변경할 수 있다.
- 보조 컬럼 생성: 부정형 조건에 해당하는 값을 미리 계산하여 저장하는 보조 컬럼을 생성하고, 해당 컬럼에 인덱스를 생성하여 조회에 활용할 수 있다
  - 예를 들어, `is_completed`라는 보조 컬럼을 생성하여, `status`가 'COMPLETED'가 아닌 경우에 `false` 값을 저장하고, 해당 컬럼에 인덱스를 생성할 수 있다.


#### OR 조건 사용
OR 조건을 사용하는 경우, 인덱스 사용이 제한될 수 있다. 특히 OR 조건이 여러 컬럼에 걸쳐서 사용되는 경우에는 인덱스를 활용하지 못하는 경우가 많다. <br/>
인덱스는 특정 컬럼의 값을 기준으로 데이터를 빠르게 찾기 위한 자료구조이기 때문에, OR 조건이 여러 컬럼에 걸쳐서 사용되는 경우에는 인덱스를 활용하기 어렵다. <br/>

```sql
-- category, price 컬럼에 인덱스 생성
CREATE INDEX idx_category ON products (category);
CREATE INDEX idx_price ON products (price);

-- 인덱스를 활용하지 못하는 경우
SELECT * FROM products WHERE category = 'A' OR category = 'B';
SELECT * FROM products WHERE category = 'A' OR price < 1000;
```
이를 해결하기 위해서는 다음과 같은 방법들을 고려할 수 있다.
- 다른 컬림인 경우 UNION 사용: OR 조건을 각각의 SELECT 문으로 분리하고, UNION을 사용하여 결과를 합치는 방법을 사용할 수 있다.
  - 예를 들어, `SELECT * FROM products WHERE category = 'A' OR price < 1000;` 대신에 `SELECT * FROM products WHERE category = 'A' UNION SELECT * FROM products WHERE price < 1000` 와 같이 변경할 수 있다. 
    와 같이 변경할 수 있다.
- 동일 컬럼인 경우 IN 사용: OR 조건이 동일한 컬럼에 걸쳐서 사용되는 경우에는 IN 절을 사용하여 쿼리를 작성할 수 있다.
  - 예를 들어, `category = 'A' OR category = 'B'` 대신에 `category IN ('A', 'B')`와 같이 변경할 수 있다.
참고로 일부 RDBMS에서는 OR 조건에 사용시, 쿼리 최적화 과정을 통해서 인덱스를 활용하는 경우도 있다. <br/>


#### 인덱스 컬럼 함수 사용 및 가공
인덱스를 생성한 컬럼에 함수나 연산자를 사용하여 가공하는 경우, 인덱스의 값을 직접 참조할 수 없기 때문에 인덱스를 활용하지 못한다. <br/>
인덱스는 원본 데이터의 값을 기준으로 생성되고 조회되기 때문에 가공된 값은 인덱스에서 찾을 수 없다. <br/>
```sql
-- product_name 컬럼에 인덱스 생성
CREATE INDEX idx_product_name ON products (product_name);
CREATE INDEX idx_avg_rating ON products (avg_rating);

-- 인덱스를 활용하지 못하는 경우
SELECT * FROM products WHERE UPPER(product_name) = 'APPLE';
SELECT * FROM products WHERE avg_rating * 100 >= 4;
```
때문에 인덱스 컬럼을 가공하는 대신에 다음과 같은 방법들을 고려할 수 있다.
- 가공된 값을 저장하는 별도의 컬럼 생성: 가공된 값을 미리 저장하는 별도의 컬럼을 생성하고, 해당 컬럼에 인덱스를 생성하여 조회에 활용할 수 있다. 
  - 예를 들어, `UPPER(product_name)` 값을 저장하는 `upper_product_name` 컬럼을 생성하고, 해당 컬럼에 인덱스를 생성할 수 있다.
- 함수 기반 인덱스(Function-Based Index) 활용: 일부 RDBMS에서는 함수 기반 인덱스를 지원하며, 이를 활용하여 함수로 가공된 값에 대한 인덱스를 생성할 수 있다.
  - 예를 들어, Oracle에서는 `CREATE INDEX idx_upper_product_name ON products (UPPER(product_name));`와 같이 함수 기반 인덱스를 생성할 수 있다.
- 인덱스 컬럼 미가공: 가능하다면 인덱스 컬럼을 가공하지 않고 원본 값을 그대로 사용하는 쿼리로 변경할 수 있다.
  - 예를 들어, `avg_rating * 100 >= 4` 대신에 `avg_rating >= 0.04`로 변경할 수 있다.

#### 인덱스 명시적/암묵적 타입 변환
인덱스 컬럼 가공과 유사하게 명시적/암묵적 타입 변환이 발생하는 경우에도 인덱스를 활용하지 못한다. <br/>
명시적 타입 변환은 CAST, CONVERT 함수를 사용하여 데이터 타입을 변환하는 경우를 의미하며, 암묵적 타입 변환은 서로 다른 데이터 타입 간의 비교 연산이 발생하는 경우 RDBMS가 자동으로 타입을 변환하는 경우를 의미하다. 이는 인덱스가 생성된 데이터 타입과 조회 시 사용되는 데이터 타입이 일치하지 않기 때문에 인덱스를 활용하지 못한다. 마치 타입언어에서 엄격한 타입 검사를 하는 것과 유사하다. <br/>

```sql
-- products 테이블의 product_id 컬럼에 인덱스 생성, product_id 컬럼이 정수형(INT)이라고 가정
CREATE INDEX idx_product_id ON products (product_id);
-- product_stock 테이블의 product_id 컬럼에 인덱스 생성, product_id 컬럼이 문자열형(CHAR)이라고 가정
CREATE INDEX idx_orders ON product_stock (product_id);

-- 인덱스를 활용하지 못하는 경우 (명시적 타입 변환)
SELECT * FROM products WHERE CAST(product_id AS CHAR) = '1001';

-- 인덱스를 활용하지 못하는 경우 (암묵적 타입 변환)
SELECT * FROM products WHERE product_id = '1001';
SELECT * FROM products JOIN product_stock ON product_stock.product_id = products.product_id;
```



## 다른 성능 최적화 방법들
인덱스를 최적화하고 인덱스를 잘 활용하기 위하여 쿼리를 최적화함에도 불구하고, 데이터베이스의 한정된 자원으로 인해서 성능 향상이 되지 않는 경우가 있다. <br/>
이때는 데이터베이스의 리소스를 최소한으로 사용하면서 성능을 향상시키기 위한 다른 방법들을 고려해야 한다. <br/>

#### 역정규화를 통한 집계 성능 향상
역정규화란 정규화된 데이터베이스 테이블을 비정규화하여, 중복된 데이터를 허용하는 것을 의미한다. 이는 데이터의 무결성을 크게 해치는 단점이 있지만, 조회 성능을 크게 향상시킬 수 있다는 장점이 있다. <br/>
예를 들어, `post` 테이블과 `comment` 테이블이 존재한다고 가정할 때, 특정 게시글의 댓글 수를 조회하는 쿼리는 다음과 같다. <br/>
```sql
SELECT p.post_id, COUNT(c.comment_id) AS comment_count
FROM post p
LEFT JOIN comment c ON p.post_id = c.post_id
```
이는 조인 연산 및 집계 연산이 발생하기 때문에, 데이터가 많아지면 RDBMS에 큰 부하가 발생할 수 있다. 이를 해결하기 위해서 `post` 테이블에 `comment_count` 컬럼을 추가하고, 댓글이 추가/삭제될 때마다 해당 컬럼의 값을 갱신하는 방법을 사용할 수 있다. <br/>
특히 실시간 성이 중요하지 않거나, 데이터의 무결성이 크게 중요하지 않은 경우에는 역정규화를 통해 조회 성능을 크게 향상시킬 수 있다. <br/>

#### 조회 범위 축소하기 
조회 시 불필요한 데이터를 많이 조회하게 되면, 그만큼 성능 저하가 발생할 수 있다. 때문에 조회 범위를 축소하여 불필요한 데이터를 최소화하는 것이 중요하다. <br/>
예를 들어, 특정 기간 동안의 데이터를 조회하는 경우, 인덱스가 생성된 날짜 컬럼을 활용하여 조회 범위를 축소할 수 있다. <br/>
```sql
-- 인덱스가 생성된 created_at 컬럼을 활용하여 조회 범위 축소
SELECT * FROM orders
WHERE created_at >= '2023-01-01' AND created_at < '2023-02-01';
```
조회 범위 축소의 경우 배치 작업에서 특히 중요하다. 배치 작업의 경우 대량의 데이터를 처리하는데, 이때 조회 범위를 축소하지 않고 전체 데이터를 조회하게 되면 성능 저하가 발생할 수 있다. 때문에 배치 작업에서는 인덱스가 생성된 컬럼을 활용하여 조회 범위를 축소하여 정크 단위로 데이터를 처리하는 것이 좋다. <br/>

#### 서브쿼리 대신 조인 사용하기
서브쿼리는 간단하게 쿼리를 작성할 수 있다는 장점이 있지만, 성능 측면에서는 조인에 비해서 불리한 경우가 많다. <br/>
서브쿼리는 내부 쿼리가 먼저 실행되고, 그 결과를 바탕으로 외부 쿼리가 실행되기 때문에, 대량의 데이터를 처리하는 경우 성능 저하가 발생할 수 있다. <br/>
예를 들어 1,000건의 데이터를 처리하는 서브쿼리가 있다고 가정할 때, 각 


#### 애플리케이션에서 데이터 연산 및 조인하기
데이터베이스는 다양한 연산 기능 및 최적화 기능을 제공하지만, 데이터베이스는 한정적인 자원을 가지고 있기 때문에, 대량의 데이터를 복잡한 연산이나 조인을 처리하는 경우 성능 저하가 발생할 수 있다. <br/>
이는 데이터베이스를 연동하고 있는 모든 서버에 영향을 미치기 때문에, 데이터베이스의 부하를 최소화하는 것이 중요하다. 때문에 대량의 데이터를 복잡한 연산이나 조인을 처리하는 경우에는 애플리케이션에서 데이터를 연산하거나 조인하는 방법을 고려할 수 있다. <br/>
예를 들어, 대량의 데이터를 조회한 후에 애플리케이션에서 필터링, 정렬, 집계 등의 연산을 처리하거나, 여러 데이터 소스에서 데이터를 조회한 후에 애플리케이션에서 조인을 처리하는 방법을 사용할 수 있다. <br/>
이는 데이터베이스의 부하를 줄이고, 애플리케이션의 확장성을 향상시키는 데 도움이 될 수 있다. <br/>


#### 오프셋 기반 페이징 처리 대신 커서 기반 페이징 처리 사용하기
오프셋 기반 페이징 처리는 특정 페이지의 데이터를 조회하기 위해서 OFFSET과 LIMIT를 사용하는 방법이다. 하지만 오프셋 기반 페이징 처리는 OFFSET 값이 커질수록 성능 저하가 발생할 수 있다. <br/>
이는 OFFSET 값이 커질수록 RDBMS가 더 많은 데이터를 스캔해야 하기 때문이다. 예를 들어, 1,000건의 데이터를 조회하는 경우, OFFSET이 900인 경우에는 900건의 데이터를 스캔해야 한다. <br/>
이를 해결하기 위해서는 커서 기반 페이징 처리를 사용하는 방법을 고려할 수 있다. <br/>
커서 기반 페이징 처리는 마지막으로 조회한 데이터의 위치를 기준으로 다음 페이지의 데이터를 조회하는 방법이다. <br/>
```sql
-- 오프셋 기반 페이징 처리
SELECT * FROM products
ORDER BY product_id
LIMIT 10 OFFSET 900;
-- 커서 기반 페이징 처리
SELECT * FROM products
WHERE product_id > 900
ORDER BY product_id
LIMIT 10;
```

#### Count 쿼리 최적화 하기
Count 쿼리는 특정 조건에 맞는 레코드의 개수를 조회하는 쿼리이다. 특히 게시판과 같은 로직에서 전체 레코드 수를 조회하여 페이지네이션을 처리하거나 총 레코드 수를 표시하는 경우에 자주 사용된다. <br/>
하지만 Count 쿼리는 대량의 데이터를 처리하는 경우 성능 저하가 발생할 수 있다. 이는 Count 쿼리가 조건에 맞는 모든 레코드를 스캔해야 하기 때문이다. <br/>
이를 해결하기 위해서는 다음과 같은 방법들을 고려할 수 있다.
- 별도의 카운트 테이블 생성: 특정 조건에 맞는 레코드 수를 미리 계산하여 저장하는 별도의 카운트 테이블을 생성하고, 해당 테이블에서 카운트 값을 조회하는 방법을 사용할 수 있다. 
  - 예를 들어, 게시판의 전체 게시글 수를 저장하는 `post_count` 테이블을 생성하고, 게시글이 추가/삭제될 때마다 해당 테이블의 값을 갱신하는 방법을 사용할 수 있다.
- 캐시 활용: 자주 조회되는 카운트 값을 캐시에 저장하고, 캐시에서 카운트 값을 조회하는 방법을 사용할 수 있다. 

#### 오래된 데이터 아카이빙 하기
오래된 데이터는 자주 조회되지 않기 때문에 데이터베이스의 성능에 큰 영향을 미치지 않는다. 하지만 오래된 데이터가 데이터베이스에 계속해서 쌓이게 되면, 데이터베이스의 크기가 커지고, 인덱스 스캔 효율성이 떨어지기 때문에 성능 저하가 발생할 수 있다. 물론 오래된 데이터를 데이터베이스에서 삭제한다고 하여도, 데이터베이스의 크기가 즉시 줄어들지 않는 경우도 있다. 이는 데이터베이스가 내부적으로 데이터를 삭제한 공간을 재사용하지 않기 때문이다. 
<br/>
때문에 오래된 데이터를 주기적으로 아카이빙하여, 데이터베이스의 크기를 관리하는 것이 중요하다. <br/>
오래된 데이터를 아카이빙하는 방법으로는 다음과 같은 방법들을 고려할 수 있다.
- 별도의 아카이빙 테이블 생성: 오래된 데이터를 별도의 아카이빙 테이블로 이동시키는 방법을 사용할 수 있다. 
  - 예를 들어, 1년 이상된 데이터를 `archive_orders` 테이블로 이동시키는 방법을 사용할 수 있다.
- 외부 스토리지 활용: 오래된 데이터를 외부 스토리지(예: AWS S3, Google Cloud Storage 등)에 저장하는 방법을 사용할 수 있다. 
  - 예를 들어, 오래된 데이터를 CSV 파일로 추출하여 외부 스토리지에 저장하는 방법을 사용할 수 있다.
- 파티셔닝 활용: 일부 RDBMS에서는 테이블 파티셔닝을 지원하며, 이를 활용하여 오래된 데이터를 별도의 파티션으로 분리하는 방법을 사용할 수 있다. 
  - 예를 들어, 월별로 파티셔닝을 설정하여, 오래된 데이터를 별도의 파티션으로 분리하는 방법을 사용할 수 있다. <br/>

## 데이터베이스 설정 최적화
데이터베이스 설정 최적화는 데이터베이스의 성능을 향상시키기 위한 중요한 작업이다. <br/>
데이터베이스는 다양한 설정 옵션을 제공하며, 이러한 설정 옵션을 적절하게 조정함으로써 데이터베이스의 성능을 향상시킬 수 있다. <br/>
데이터베이스 설정 최적화 작업은 다음과 같은 방법들을 고려할 수 있다.
- 메모리 설정 최적화: 데이터베이스의 메모리 설정을 최적화하여, 데이터베이스가 더 많은 데이터를 메모리에 캐싱할 수 있도록 설정할 수 있다. 
  - 예를 들어, MySQL의 경우 `innodb_buffer_pool_size` 설정을 조정하여, InnoDB 스토리지 엔진이 더 많은 데이터를 메모리에 캐싱할 수 있도록 설정할 수 있다.
  - 또한 메모리 사용량 한계치를 넘게 되는 경우 임시 파일을 디스크에 생성하게 되는데, 이로 인해서 성능 저하가 발생할 수 있다. 때문에 임시 파일이 디스크에 생성되지 않도록 메모리 설정을 최적화하는 것이 중요하다. 설정으로는 `tmp_table_size`, `max_heap_table_size` 등이 있다.
- 연결 설정 최적화: 데이터베이스의 연결 설정을 최적화하여, 데이터베이스에 대한 연결 수를 적절하게 조정할 수 있다. 
  - 예를 들어, MySQL의 경우 `max_connections` 설정을 조정하여, 데이터베이스에 대한 최대 연결 수를 설정할 수 있다.
- 쓰기 성능 설정 최적화: 데이터베이스의 쓰기 성능 설정을 최적화하여, 데이터베이스의 쓰기 작업을 효율적으로 처리할 수 있도록 설정할 수 있다. 
  - 예를 들어, MySQL의 경우 `innodb_flush_log_at_trx_commit` 설정을 조정하여, 트랜잭션 커밋 시 로그 플러시 방식을 설정할 수 있다.
- 