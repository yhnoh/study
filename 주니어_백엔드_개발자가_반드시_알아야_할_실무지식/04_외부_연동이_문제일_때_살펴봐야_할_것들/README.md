## 시스템 연동
현대의 애플리케이션은 다양한 외부 시스템 및 내부 시스템과 연동되어 동작하는 경우가 많다. 예를 들면 결제 시스템, 메시징 시스템, 채팅 시스템, 클라우드 서비스와 같은 외부 시스템 및 MSA 아키텍처에서 다른 마이크로서비스와의 연동과 같은 내부 시스템 연동 등 다양한 연동을 통하여 기능을 제공한다. <br/>
이러한 시스템과의 연동을 통해서 **_직접 구현해야 하는 기능의 범위를 줄여 개발의 편의성을 높이고_**, 검증된 시스템의 기능을 활용하여 **_애플리케이션의 안정성과 신뢰성을 높일 수 있다._** <br/>
하지만 시스템과의 연동을 통해서 발생할 수 있는 여러 가지 문제점들도 존재한다. <br/>
- 외부 시스템의 장애로 인한 애플리케이션 장애
- 외부 시스템과의 통신 지연으로 인한 애플리케이션 성능 저하
- 트랜잭션 관리의 어려움

따라서 외부 시스템과의 연동을 설계할 때에는 이러한 문제점들을 고려하여 신중하게 접근해야 한다. 특히 중요한 서비스일 수록 외부 시스템의 스펙을 꼼꼼히 검토하고, 문제 발생 시 대응 방안을 미리 마련해 두는 것이 필요하다. 만약 자동으로 대응하기 어려운 문제라면, 수동으로 대응할 수 있는 절차를 마련해 두는 것도 좋은 방법이다. <br/>

## 외부 시스템과의 연동에서 고려해야 할 사항들

### 타임아웃
외부 시스템과의 연동시에 가장 중요한 설정이 타임아웃 설정이다. 타임아웃이란 외부 시스템과의 통신에서 **_일정 시간 동안 응답이 없을 때, 통신을 중단하고 오류를 반환하는 설정을 의미_** 한다. <br/>
만약 타임아웃을 너무 길게 설정하면 외부 시스템이 늦게 응답할 때 애플리케이션이 오랫동안 대기하게 되면 **_스레드 풀이 고갈되어 다른 클라이언트의 요청 처리에도 영향을 미쳐서 전체 시스템의 성능 저하_** 로 이어질 수 있다. <br/>
반대로 타임아웃을 너무 짧게 설정하면 외부 시스템이 정상적으로 응답하는 경우에도 타임아웃이 발생하여 오류가 반환될 수 있다. 이는 **_사용자 경험을 저하_** 시킬 수 있다. <br/>
따라서 타임아웃 설정은 외부 시스템의 특성과 애플리케이션의 요구사항을 고려하여 적절하게 설정해야 한다.

#### 타임아웃 설정 시 고려해야 할 사항들
**_1. 외부 시스템의 평균 응답 시간 고려_** <br/>
APM 도구를 활용하여 외부 시스템의 응답 시간을 측정하여 평균 응답 시간을 파악하고, 평균 응답 시간보다 약간 여유 있게 타임아웃을 설정하면 보다 안정적으로 외부 시스템과의 통신을 할 수 있다. <br/>
TCP 통신의 경우 타임아웃은 크게 연결 타임아웃, 읽기 타임아웃, 쓰기 타임아웃으로 나뉘게 해당 타임아웃이 어떤 상황에서 발생하는지를 이해하는 것도 중요하다. <br/>
- 연결 타임아웃: 서버간 Connection을 맺는 과정에서 타임아웃이 발생하는 경우
  - 예를 들어, 외부 시스템이 다운되어 있거나, 네트워크 장애로 인하여 서버간 연결이 이루어지지 않는 경우에 발생할 수 있다.
- 읽기 타임아웃: 서버로부터 응답을 기다리는 과정에서 타임아웃이 발생하는 경우
  - 예를 들어, 외부 시스템이 과부하 상태로 인해 응답이 지연되는 경우에 발생할 수 있다.
- 쓰기 타임아웃: 서버로 요청을 보내는 과정에서 타임아웃이 발생하는 경우
  - 예를 들어, 대용량 파일업로드와 같은 요청 본문이 너무 크기거나 네트워크 지연이 심한 경우에 발생할 수 있다.

**_2. 애플리케이션의 요구 사항 및 외부 시스템의 성격 고려_** <br/>
단순히 외부 시스템의 평균 응답 시간만 고려하는 것이 아니라, 애플리케이션의 요구 사항과 외부 시스템의 성격을 고려하여 타임아웃을 설정하는 것도 중요하다. <br/>
결제 시스템의 경우 고객의 결제 실패 경험을 최소화하고, 결제를 일으키기 위하여 타임아웃을 길게 설정할 수 있지만, SMS, Slack, 카카오톡, 메일과 같은 메시징 시스템의 경우 타임아웃을 짧게 설정하여 애플리케이션에 성능을 저하시키지 않도록 하는 것이 좋다. <br/>
절대적으로 정답이 있는 것이 아니며 어떠한 요구사항이냐에 따라서 개발자가 적절하게 판단하여 타임아웃을 설정하는 것이 필요하다. <br/>


### 커넥션 풀
커넥션 풀은 외부 시스템과의 통신에서 **_커넥션을 재사용하여 연결을 맺는 과정을 최소화하기 위한 방법_** 중 하나이다. 커넥션을 맺는 과정에서도 시간이 소요되기 때문에, 커넥션 풀을 사용하여 커넥션을 재사용하면 성능을 향상시킬 수 있다. <br/>
커넥션 풀을 사용할 때에는 다음과 같은 사항들을 고려해야 한다.
- 커넥션 풀의 크기 설정
- 커넥션 획득을 위한 타임아웃 설정
- 커넥션 최대 유지 시간 (Keep-Alive, Max Lifetime) 설정

#### 커넥션 풀 설정 시 고려해야 할 사항들

**_1. 커넥션 풀의 크기 설정_** <br/>
커넥션 풀의 크기는 **_외부 시스템과의 통신에서 동시에 처리할 수 있는 요청의 수를 결정_** 하는 중요한 설정이다. <br/>
커넥션 풀의 크기를 너무 작게 설정하면 동시에 처리할 수 있는 요청수가 제한되어 애플리케이션의 성능이 저하될 수 있다. 반대로 커넥션 풀의 크기를 너무 크게 설정하면, 외부 시스템에 과도한 부하를 줄 수 있다. <br/>
특정 자원의 경우 최대 커넥션 수가 제한되어 있는 경우가 많기 때문에, 커넥션 풀의 크기를 외부 시스템의 최대 커넥션 수보다 크게 설정하는 것은 바람직하지 않다. <br/>

**_2. 커넥션 획득을 위한 타임아웃 설정_** <br/>
커넥션 풀에서 커넥션을 획득하기 위한 타임아웃 설정도 중요하다. 예를 들어 **_커넥션 풀에서 커넥션이 모두 사용 중인 경우, 커넥션을 획득하기 위해 대기_** 해야 하는 상황이 발생할 수 있다. <br/>
이때 타임아웃을 길게 설정하면 애플리케이션이 오랫동안 대기하게 되어 성능 저하로 이어질 수 있다. 반대로 타임아웃을 짧게 설정하면 커넥션을 획득하지 못하는 경우가 발생하여 오류가 반환될 수 있다. <br/>

**_3. 커넥션 최대 유지 시간 (Keep-Alive, Max Lifetime) 설정_** <br/>
커넥션 풀에서 각 커넥션들이 일정 시간 동안 유지되는 최대 시간을 설정하는 것도 중요하다. <br/>
커넥션을 너무 오래 유지하면, 외부 시스템에서 커넥션이 끊어지는 경우가 발생할 수 있다. 반대로 커넥션을 너무 짧게 유지하면, 커넥션을 자주 생성하고 종료하는 과정에서 성능 저하로 이어질 수 있다. <br/>
특정 자원의 경우 얼마만큼 커넥션을 유지할 수 있는지에 대한 제한이 있을 수 있기 때문에, **_커넥션 최대 유지 시간을 외부 시스템의 제한보다 짧게 설정하는 것_** 이 좋다. <br/>


### 동시 요청 제한
외부 요청으로 부터 우리의 애플리케이션의 과도한 요청을 방지하기 위해서 동시 요청 제한을 설정할 수도 있지만, 동시에 외부 시스템에 대한 과도한 요청을 방지하기 위해서도 동시 요청 제한을 설정할 수 있다. <br/>
우리의 애플리케이션이 외부 시스템에 과도한 요청을 보내는 경우, 외부 시스템이 과부화 상태에 빠지거나 장애가 발생할 수 있다. 또한 외부 시스템이 이러한 과부하 상태를 막기 위하여 동시 요청 제한을 설정하는 경우도 있다. <br/>
이러한 경우 동시 요청 제한을 설정하여, 외부 시스템에 과도한 요청이 발생하는 것을 방지할 수 있다. <br/>
동시 요청 구현시 주로 사용되는 방법으로는 세마포어(Semaphore)와 토큰 버킷(Token Bucket) 알고리즘이 있다. <br/>

#### 동시 요청 구현시 주로 사용되는 방법들

동시 요청 제한 메커니즘을 구현하기 위해서 주로 사용되는 방법으로는 세마포어(Semaphore)와 토큰 버킷(Token Bucket) 알고리즘이 있다. <br/>
해당 메커니즘을 구현하기위해 주로 분산환경에서 인메모리 데이터베이스인 Redis를 활용하거나, Java 라이브러리에서는 Bucket4j, Resilience4j, Guava RateLimiter 등을 활용하여 동시 요청 제한을 구현할 수 있다.<br/>

**_1. 세마포어(Semaphore)_**
세마포어는 동시 요청을 제한하기 위한 동기화 도구로, 일정한 수의 허용된 요청 수를 설정하여, 동시에 처리할 수 있는 요청의 수를 제한하는 방식이다. <br/>
예를 들어, 세마포어의 허용된 요청 수를 10으로 설정하면, 동시에 최대 10개의 요청만 처리할 수 있도록 제한할 수 있다. <br/>

**_2. 토큰 버킷(Token Bucket) 알고리즘_**
토큰 버킷 알고리즘은 특정 시간 동안 몇초의 요청을 허용할 것인지를 설정하는 방식으로, 일정한 속도로 토큰이 생성되는 버킷을 사용하여, 요청이 들어올 때마다 토큰을 소비하는 방식으로 동시 요청을 제한하는 방법이다. <br/>
예를 들어, 토큰 버킷의 생성 속도를 1000ms당 1개로 설정하면, 1000ms마다 1개의 토큰이 생성되고, 요청이 들어올 때마다 토큰을 소비하여, 동시에 처리할 수 있는 요청의 수를 제한할 수 있다. <br/>


### 재시도 
외부 시스템과의 통신에서 일시적인 네트워크 문제, 외부 시스템의 일시적인 장애, 외부 시스템의 과부화로 인하여 통신이 실패하는 경우가 발생할 수 있다. <br/>
이러한 경우 재시도 메커니즘을 구현하여 일시적인 문제로 인한 통신 실패를 최소화할 하여 사용자 경험을 개선하며 데이터 정합성을 유지할 수 있다. <br/>
하지만 재시도 메커니즘을 구현할 때에는 다음과 같은 사항들을 고려해야 한다. <br/>
- 재시도 횟수와 간격 설정: 재시도 횟수와 간격을 적절하게 설정하여, 일시적인 문제로 인한 통신 실패를 최소화하면서도, 외부 시스템에 과도한 부하를 주지 않도록 해야 한다. 일반적으로 재시도 횟수는 3회에서 5회 정도로 설정하고, 재시도 간격은 점진적으로 증가하는 방식(예: 1초, 2초, 4초)으로 설정하는 것이 좋다.
- 재시도 시점에서의 상태 관리: 재시도 시점에서 애플리케이션의 상태를 적절하게 관리하여, 재시도 과정에서 발생할 수 있는 데이터 정합성 문제를 방지해야 한다. 예를 들어, 재시도 시점에서 트랜잭션을 롤백하거나, 재시도 시점에서 발생한 오류를 적절하게 처리하여, 데이터 정합성을 유지할 수 있도록 해야 한다.
- 재시도 실패 시의 대응 방안 마련: 재시도 메커니즘이 실패할 경우에 대한 대응 방안을 마련하여, 사용자에게 적절한 피드백을 제공하고, 시스템의 안정성을 유지할 수 있도록 해야 한다. 예를 들어, 재시도 실패 시 사용자에게 오류 메시지를 표시하거나, 재시도 실패 시 관리자에게 알림을 보내는 등의 대응 방안을 마련하는 것이 좋다.
- 재시도 메커니즘의 모니터링 및 로깅: 재시도 메커니즘이 제대로 작동하는지 모니터링하고, 재시도 과정에서 발생하는 오류를 로깅하여, 문제 발생 시 신속하게 대응할 수 있도록 해야 한다. 예를 들어, 재시도 횟수, 재시도 간격, 재시도 실패 시의 오류 메시지 등을 로깅하여, 문제 발생 시 원인을 파악하고 대응할 수 있도록 하는 것이 좋다.
- 재시도 메커니즘의 테스트: 재시도 메커니즘이 제대로 작동하는지 테스트하여, 문제 발생 시 신속하게 대응할 수 있도록 해야 한다. 예를 들어, 외부 시스템의 일시적인 장애를 시뮬레이션하여 재시도 메커니즘이 제대로 작동하는지 테스트하는 것이 좋다.
- 재시도 메커니즘의 구현 방식 고려: 재시도 메커니즘을 구현할 때에는, 애플리케이션의 요구 사항과 외부 시스템의 특성에 따라 적절한 구현 방식을 선택해야 한다. 예를 들어, 재시도 메커니즘을 애플리케이션 레벨에서 구현할 수도 있고, 외부 시스템에서 제공하는 재시도 기능을 활용할 수도 있다. 또한, 재시도 메커니즘을 구현할 때에는, 애플리케이션의 아키텍처와 기술 스택에 맞는 구현 방식을 선택하는 것이 중요하다.




### 재시도 메커니즘 구현 시 고려해야 할 사항들

#### 1. 재시도


### 서킷 브레이커



