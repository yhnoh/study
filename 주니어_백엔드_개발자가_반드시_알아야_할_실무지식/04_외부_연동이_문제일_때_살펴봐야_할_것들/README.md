## 시스템 연동
현대의 애플리케이션은 다양한 외부 시스템 및 내부 시스템과 연동되어 동작하는 경우가 많다. 예를 들면 결제 시스템, 메시징 시스템, 채팅 시스템, 클라우드 서비스와 같은 외부 시스템 및 MSA 아키텍처에서 다른 마이크로서비스와의 연동과 같은 내부 시스템 연동 등 다양한 연동을 통하여 기능을 제공한다. <br/>
이러한 시스템과의 연동을 통해서 **_직접 구현해야 하는 기능의 범위를 줄여 개발의 편의성을 높이고_**, 검증된 시스템의 기능을 활용하여 **_애플리케이션의 안정성과 신뢰성을 높일 수 있다._** <br/>
하지만 시스템과의 연동을 통해서 발생할 수 있는 여러 가지 문제점들도 존재한다. <br/>
- 외부 시스템의 장애로 인한 애플리케이션 장애
- 외부 시스템과의 통신 지연으로 인한 애플리케이션 성능 저하
- 트랜잭션 관리의 어려움

따라서 외부 시스템과의 연동을 설계할 때에는 이러한 문제점들을 고려하여 신중하게 접근해야 한다. 특히 중요한 서비스일 수록 외부 시스템의 스펙을 꼼꼼히 검토하고, 문제 발생 시 대응 방안을 미리 마련해 두는 것이 필요하다. 만약 자동으로 대응하기 어려운 문제라면, 수동으로 대응할 수 있는 절차를 마련해 두는 것도 좋은 방법이다. <br/>

## 외부 시스템과의 연동에서 고려해야 할 사항들

### 타임아웃
외부 시스템과의 연동시에 가장 중요한 설정이 타임아웃 설정이다. 타임아웃이란 외부 시스템과의 통신에서 **_일정 시간 동안 응답이 없을 때, 통신을 중단하고 오류를 반환하는 설정을 의미_** 한다. <br/>
만약 타임아웃을 너무 길게 설정하면 외부 시스템이 늦게 응답할 때 애플리케이션이 오랫동안 대기하게 되어 **_스레드 풀이 고갈되어 다른 클라이언트의 요청 처리에도 영향을 미쳐서 전체 시스템의 성능 저하_** 로 이어질 수 있다. <br/>
반대로 타임아웃을 너무 짧게 설정하면 외부 시스템이 정상적으로 응답하는 경우에도 타임아웃이 발생하여 오류가 반환될 수 있다. 이는 **_사용자 경험을 저하_** 시킬 수 있다. <br/>
따라서 타임아웃 설정은 외부 시스템의 특성과 애플리케이션의 요구사항을 고려하여 적절하게 설정해야 한다.

#### 타임아웃 설정 시 고려해야 할 사항들
**_1. 외부 시스템의 평균 응답 시간 고려_** <br/>
APM 도구를 활용하여 외부 시스템의 응답 시간을 측정하여 평균 응답 시간을 파악하고, 평균 응답 시간보다 약간 여유 있게 타임아웃을 설정하면 보다 안정적으로 외부 시스템과의 통신을 할 수 있다. <br/>
TCP 통신의 경우 타임아웃은 크게 연결 타임아웃, 읽기 타임아웃, 쓰기 타임아웃으로 나뉘게 해당 타임아웃이 어떤 상황에서 발생하는지를 이해하는 것도 중요하다. <br/>
- 연결 타임아웃: 서버간 Connection을 맺는 과정에서 타임아웃이 발생하는 경우
  - 예를 들어, 외부 시스템이 다운되어 있거나, 네트워크 장애로 인하여 서버간 연결이 이루어지지 않는 경우에 발생할 수 있다.
- 읽기 타임아웃: 서버로부터 응답을 기다리는 과정에서 타임아웃이 발생하는 경우
  - 예를 들어, 외부 시스템이 과부하 상태로 인해 응답이 지연되는 경우에 발생할 수 있다.
- 쓰기 타임아웃: 서버로 요청을 보내는 과정에서 타임아웃이 발생하는 경우
  - 예를 들어, 대용량 파일업로드와 같은 요청 본문이 너무 크거나 네트워크 지연이 심한 경우에 발생할 수 있다.

**_2. 애플리케이션의 요구 사항 및 외부 시스템의 성격 고려_** <br/>
단순히 외부 시스템의 평균 응답 시간만 고려하는 것이 아니라, 애플리케이션의 요구 사항과 외부 시스템의 성격을 고려하여 타임아웃을 설정하는 것도 중요하다. <br/>
결제 시스템의 경우 고객의 결제 실패 경험을 최소화하고, 결제를 일으키기 위하여 타임아웃을 길게 설정할 수 있지만, SMS, Slack, 카카오톡, 메일과 같은 메시징 시스템의 경우 타임아웃을 짧게 설정하여 애플리케이션에 성능을 저하시키지 않도록 하는 것이 좋다. <br/>
절대적으로 정답이 있는 것이 아니며 어떠한 요구사항이냐에 따라서 개발자가 적절하게 판단하여 타임아웃을 설정하는 것이 필요하다. <br/>


### 커넥션 풀
커넥션 풀은 외부 시스템과의 통신에서 **_커넥션을 재사용하여 연결을 맺는 과정을 최소화하기 위한 방법_** 중 하나이다. 커넥션을 맺는 과정에서도 시간이 소요되기 때문에, 커넥션 풀을 사용하여 커넥션을 재사용하면 성능을 향상시킬 수 있다. <br/>
커넥션 풀을 사용할 때에는 다음과 같은 사항들을 고려해야 한다.
- 커넥션 풀의 크기 설정
- 커넥션 획득을 위한 타임아웃 설정
- 커넥션 최대 유지 시간 (Keep-Alive, Max Lifetime) 설정

#### 커넥션 풀 설정 시 고려해야 할 사항들

**_1. 커넥션 풀의 크기 설정_** <br/>
커넥션 풀의 크기는 **_외부 시스템과의 통신에서 동시에 처리할 수 있는 요청의 수를 결정_** 하는 중요한 설정이다. <br/>
커넥션 풀의 크기를 너무 작게 설정하면 동시에 처리할 수 있는 요청수가 제한되어 애플리케이션의 성능이 저하될 수 있다. 반대로 커넥션 풀의 크기를 너무 크게 설정하면, 외부 시스템에 과도한 부하를 줄 수 있다. <br/>
특정 자원의 경우 최대 커넥션 수가 제한되어 있는 경우가 많기 때문에, 커넥션 풀의 크기를 외부 시스템의 최대 커넥션 수보다 크게 설정하는 것은 바람직하지 않다. <br/>

**_2. 커넥션 획득을 위한 타임아웃 설정_** <br/>
커넥션 풀에서 커넥션을 획득하기 위한 타임아웃 설정도 중요하다. 예를 들어 **_커넥션 풀에서 커넥션이 모두 사용 중인 경우, 커넥션을 획득하기 위해 대기_** 해야 하는 상황이 발생할 수 있다. <br/>
이때 타임아웃을 길게 설정하면 애플리케이션이 오랫동안 대기하게 되어 성능 저하로 이어질 수 있다. 반대로 타임아웃을 짧게 설정하면 커넥션을 획득하지 못하는 경우가 발생하여 오류가 반환될 수 있다. <br/>

**_3. 커넥션 최대 유지 시간 (Keep-Alive, Max Lifetime) 설정_** <br/>
커넥션 풀에서 각 커넥션들이 일정 시간 동안 유지되는 최대 시간을 설정하는 것도 중요하다. <br/>
커넥션을 너무 오래 유지하면, 외부 시스템에서 커넥션이 끊어지는 경우가 발생할 수 있다. 반대로 커넥션을 너무 짧게 유지하면, 커넥션을 자주 생성하고 종료하는 과정에서 성능 저하로 이어질 수 있다. <br/>
특정 자원의 경우 얼마만큼 커넥션을 유지할 수 있는지에 대한 제한이 있을 수 있기 때문에, **_커넥션 최대 유지 시간을 외부 시스템의 제한보다 짧게 설정하는 것_** 이 좋다. <br/>


### 동시 요청 제한
외부 요청으로 부터 우리의 애플리케이션의 과도한 요청을 방지하기 위해서 동시 요청 제한을 설정할 수도 있지만, 동시에 **_외부 시스템에 대한 과도한 요청을 방지하기 위해서도 동시 요청 제한을 설정_**할 수 있다. <br/>
우리의 애플리케이션이 외부 시스템에 과도한 요청을 보내는 경우, 외부 시스템이 과부하 상태에 빠지거나 장애가 발생할 수 있다. 또한 외부 시스템이 이러한 과부하 상태를 막기 위하여 동시 요청 제한을 설정하는 경우도 있다. <br/>
이러한 경우 동시 요청 제한을 설정하여, 외부 시스템에 과도한 요청이 발생하는 것을 방지할 수 있다. <br/>

#### 동시 요청 구현시 주로 사용되는 방법들

동시 요청 제한 메커니즘을 구현하기 위해서 주로 사용되는 방법으로는 세마포어(Semaphore)와 토큰 버킷(Token Bucket) 알고리즘이 있다. <br/>
해당 메커니즘을 구현하기위해 주로 분산환경에서 인메모리 데이터베이스인 Redis를 활용하거나, Java 라이브러리에서는 Bucket4j, Resilience4j, Guava RateLimiter 등을 활용하여 동시 요청 제한을 구현할 수 있다.<br/>

**1. 세마포어(Semaphore)** <br/>
세마포어는 동시 요청을 제한하기 위한 동기화 도구로, **_일정한 수의 허용된 요청 수를 설정하여, 동시에 처리할 수 있는 요청의 수를 제한_** 하는 방식이다. <br/>
예를 들어, 세마포어의 허용된 요청 수를 10으로 설정하면, 동시에 최대 10개의 요청만 처리할 수 있도록 제한할 수 있다. <br/>

**2. 토큰 버킷(Token Bucket) 알고리즘** <br/>
토큰 버킷 알고리즘은 **_특정 시간 동안 몇초의 요청을 허용할 것인지를 설정하는 방식_** 으로, 일정한 속도로 토큰이 생성되는 버킷을 사용하여, 요청이 들어올 때마다 토큰을 소비하는 방식으로 동시 요청을 제한하는 방법이다. <br/>
예를 들어, 토큰 버킷의 생성 속도를 1000ms당 1개로 설정하면, 1000ms마다 1개의 토큰이 생성되고, 요청이 들어올 때마다 토큰을 소비하여, 동시에 처리할 수 있는 요청의 수를 제한할 수 있다. <br/>


### 재시도 
외부 시스템과의 통신에서 일시적인 네트워크 문제, 외부 시스템의 일시적인 장애, 외부 시스템의 일시적인 과부하 등으로 인해 통신이 실패할 수 있다. <br/>
이러한 경우 재시도 메커니즘을 구현하여 **_일시적인 문제로 인한 통신 실패를 최소화하여 사용자 경험을 개선하며 데이터 정합성을 유지_** 할 수 있다. <br/>
재시도 메커니즘은 모든 상황에 적용되는 것은 아니며, 적용 가능한 상황에 적절하게 적용하는 것이 중요하다. 또한 재시도 매커니즘 구현시 몇가지를 고려해야한다.

- 멱등성 보장
- 어떤 상황에서 재시도를 할 것인지에 대한 기준 설정
- 재시도 횟수와 간격 설정
- 재시도 실패 이후 대응 방안 마련

#### 재시도 메커니즘 구현 시 고려해야 할 사항들

**1. 멱등성(Idempotency) 보장** <br/>
멱등성이란 동일한 요청을 여러번 수행하더라도 결과가 동일하게 나오는 것을 의미한다. 재시도의 경우 동일한 요청이 여러번 수행될 수 있기 때문에, 멱등성을 보장하는 것이 중요하다. <br/>
상태를 변경하는 요청의 경우 멱등성을 보장하는 것이 중요하다. 예를 들어 결제 요청과 같은 경우, 동일한 요청이 여러번 수행되면 중복 결제가 발생할 수 있기 때문에, 멱등성을 보장하는 것이 중요하며 주로 멱등 키(Idempotency Key)를 활용하여 멱등성을 보장하는 방법이 많이 사용된다. <br/>
> 멱등 키(Idempotency Key): 클라이언트가 요청을 보낼 때, 고유한 키를 함께 보내는 방식으로, 서버는 해당 키를 기반으로 요청의 중복 여부를 판단하여 멱등성을 보장하는 방법이다. RDS에서는 UNIQUE 제약 조건을 활용하여 멱등 키를 저장하는 방식으로 멱등성을 보장할 수 있다. <br/>
반대로 상태를 조회하는 요청의 경우, 동일한 요청이 여러번 수행되더라도 결과가 동일하게 나오기 때문에, 멱등성을 보장하는 것이 상대적으로 덜 중요할 수 있다.


**2. 어떤 상황에서 재시도를 할 것인지에 대한 기준 설정** <br/>
재시도를 수행할 상황을 명확히 정의하는 것이 중요하다. 예를 들어, 일시적인 네트워크 오류 또는 외부 시스템의 일시적인 장애로 인한 오류와 같은 5xx 서버 오류에 대해서는 재시도를 수행할 수 있지만, 클라이언트의 잘못된 요청으로 인한 4xx 오류에 대해서는 재시도를 수행하지 않는 것이 일반적이다. <br/>
- 4xx 오류시 재시도 수행 X: 클라이언트의 잘못된 요청으로 인한 오류이기 때문에, 재시도를 수행해도 동일한 오류가 발생할 가능성이 높다.
- 5xx 오류시 재시도 수행 O: 일시적인 네트워크 오류 또는 외부 시스템의 일시적인 장애로 인한 오류이기 때문에, 재시도를 수행하면 통신이 성공할 가능성이 있다. <br/>

하지만 저러한 기준은 절대적인 것은 아니며, 애플리케이션의 요구사항과 외부 시스템의 특성에 따라서 재시도를 수행할 상황에 대한 기준을 적절하게 설정하는 것이 필요하다. <br/>
예를들어 읽기 타임아웃(504: Gateway Timeout)의 경우, 에러가 발생하였다고 하여도 외부 서버는 요청을 정상적으로 처리하였을 가능성이 있기 때문에 재시도를 수행하지 않는 것이 멱등성을 보장하는 측면에서 좋을 수 있다. 반대로 쓰기 타임아웃(408: Request Timeout)의 경우, 요청이 일시적인 네트워크 지연으로 인하여 외부 서버에 도달하지 않았을 가능성이 있기 때문에 재시도를 수행하는 것이 좋을 수 있다. <br/>
또한 외부 시스템의 경우 각 스펙별로 HTTP 상태 코드나 Response Body가 다르게 정의되어 있을 수 있기 때문에, 외부 시스템의 스펙을 꼼꼼히 검토하여 재시도를 수행할 상황에 대한 기준을 적절하게 설정하는 것이 필요하다. <br/>

**3. 재시도 횟수와 간격 설정** <br/>
재시도를 무한히 수행할 수는 없기 때문에, 재시도 횟수와 간격을 적절하게 설정하는 것이 중요하다. <br/>

재시도 횟수
- 재시도 횟수를 너무 많이 설정하게 되면, 일시적인 문제를 최소화할 수 있지만 과도한 재시도로 인하여 외부 시스템에 부담을 줄 수 있다. (Retry Storm: 재시도 폭풍)
- 재시도 횟수를 너무 적게 설정하게 되면, 일시적인 문제로 인한 통신 실패를 최소화할 수 없게 된다. <br/>
  
재시도 간격
- 재시도 간격을 너무 짧게 설정하게 되면, 동일한 문제로 인하여 재시도가 연속적으로 실패할 가능성이 높아진다.
- 재시도 간격을 너무 길게 설정하게 되면, 동일한 문제를 최소화 할 수 있지만 애플리케이션의 스레드 풀이 고갈되어 다른 클라이언트의 요청 처리에도 영향을 미쳐서 전체 시스템의 성능 저하로 이어질 수 있다. <br/>
 
일반적으로 재시도 횟수는 2회 이내로 설정하는 것이 일반적이며, 재시도 간격은 고정된 간격보다는 지수 백오프(Exponential Backoff)나 지터(Jitter)와 같은 방법을 활용하여, 재시도 간격을 점차적으로 늘려가는 방식이 일반적으로 권장된다. <br/>

**4. 재시도 실패 이후 대응 방안 마련**  <br/>
재시도를 수행하였음에도 불구하고 실패하는 경우에 대한 대응 방안을 마련해야할 필요성이 있을 수 있다. 예를 들어, 재시도 횟수를 초과하여 실패하는 경우, 사용자에게 오류 메시지를 반환하거나, 실패한 요청을 별도의 큐나 데이터베이스에 저장하여 나중에 수동으로 재처리할 수 있도록 하는 등의 대응 방안을 마련하는 것이 필요할 수 있다. <br/>
특히 별도의 큐나 데이터베이스에 저장하여 나중에 수동으로 재처리할 수 있도록 하는 방식은, 비동기 통신이나 메시징 시스템과의 연동에서 자주 사용되는 방식으로, 재시도 메커니즘이 적용된 요청이 실패하는 경우, 해당 요청을 별도의 큐나 데이터베이스에 저장하여 나중에 수동으로 재처리할 수 있도록 하는 방식이다. <br/>

### 서킷 브레이커
서킷 브레이커는 외부 시스템과의 통신에서 일시적인 문제로 인하여 실패 임계치를 초과하는 경우, 일정 기간 동안 해당 외부 시스템과의 통신을 중단하여, 애플리케이션이 빠르게 실패하도록 하는 메커니즘(Fail-fast)이다. <br/>
특히 타임아웃이 지속적으로 발생할 때 클라이언트가 지속적으로 요청을 보내는 경우, 커넥션 풀이 고갈되어 서비스 전체의 성능 저하로 이어질 수 있기 때문에, 서킷 브레이커를 활용하여 빠르게 실패하도록 하는 것이 좋다. <br/>

#### 서킷 브레이커의 상태
서킷 브레이커는 일반적으로 다음과 같은 세 가지 상태로 동작한다
- Closed: 정상적으로 통신이 이루어지는 상태로, 모든 요청이 외부 시스템으로 전달된다.
- Open: 실패 임계치를 초과하여 통신이 중단된 상태로, 모든 요청이 즉시 실패로 반환된다.
- Half-Open: 일정 기간이 지난 후, 일부 요청을 외부 시스템으로 전달하여 통신이 정상적으로 이루어지는지 확인하는 상태로, 통신이 정상적으로 이루어지는 경우 Closed 상태로 전환되고, 통신이 여전히 실패하는 경우 Open 상태로 다시 전환된다. <br/>


#### 서킷 브레이커 상태 변경을 위한 실패 임계치 설정
서킷 브레이커의 상태를 변경하기 위한 실패 임계치는 주로 두 가지 기준으로 설정한다.
- 횟수 기준 오류 발생 비율(Count-based): 최근 N개의 요청 중 실패한 요청의 비율이 임계치를 초과하는 경우 서킷 브레이커가 Open 상태로 전환된다.
- 시간 기준 오류 발생 비율(Time-based): 최근 N초 동안의 요청 중 실패한 요청의 비율이 임계치를 초과하는 경우 서킷 브레이커가 Open 상태로 전환된다. <br/>

위와 같은 기준을 설정하기 위해서는 외부 시스템의 특성 및 애플리케이션의 요구사항을 고려해야하며, 평소 APM 도구를 활용하여 외부 시스템과의 통신에서 발생하는 오류의 패턴을 분석하여, 적절한 기준과 임계치를 설정하는 것이 필요하다. <br/>

**1. 트래픽이 일정한 서비스** <br/>
트래픽이 일정한 서비스의 경우, 횟수 기준 오류 발생 비율(Count-based)을 활용하여 실패 임계치를 설정하는 것이 좋다. <br/>
트래픽이 일정하기 때문에 N개의 요청이 쌓이는 시간이 비교적 예측 가능하여, 일정한 수의 요청을 기준으로 오류 비율을 판단하는 것이 직관적이고 안정적이기 때문이다. <br/>
예를 들어, 최근 100개의 요청 중 50% 이상 실패하는 경우 서킷 브레이커가 Open 상태로 전환되도록 설정할 수 있다. <br/>

**2. 트래픽 변동이 심한 서비스** <br/>
트래픽이 일정하지 않은 서비스의 경우, 시간 기준 오류 발생 비율(Time-based)을 활용하여 실패 임계치를 설정하는 것이 좋다. <br/>
만약 횟수 기준(Count-based)을 사용하게 되면, 트래픽이 적은 시간대에는 N개의 요청이 쌓이는 데 오랜 시간이 걸려 장애 감지가 늦어질 수 있고, 트래픽이 많은 시간대에는 너무 빠르게 N개가 쌓여 민감하게 반응할 수 있다. <br/>
시간 기준(Time-based)은 트래픽 양에 관계없이 일정한 시간 단위로 오류 비율을 판단하기 때문에,
트래픽 변동이 심한 서비스에서 보다 안정적으로 동작한다. <br/>
예를 들어, 최근 60초 동안의 요청 중 50% 이상 실패하는 경우 서킷 브레이커가 Open 상태로 전환되도록 설정할 수 있다. <br/>

**3. 중요한 서비스** <br/>
중요한 서비스의 경우 장애가 비즈니스에 미치는 영향이 크기 때문에, 서킷 브레이커의 임계치를 보다 민감하게 설정하여 빠르게 장애를 감지하고 대응하는 것이 좋다. <br/>
예를 들어 결제 시스템의 경우, 오류 비율 임계치를 30%로 낮게 설정하여 빠르게 서킷을 열고,
Open 상태 유지 시간도 짧게 설정하여 외부 시스템이 복구되었는지 빠르게 확인하도록 할 수 있다. <br/>
반대로 덜 중요한 서비스의 경우, 오류 비율 임계치를 50%로 높게 설정하여 일시적인 문제로 인한 불필요한 서킷 오픈을 방지할 수 있다. <br/>
서비스의 중요도에 따라서 임계치와 Open 상태 유지 시간을 다르게 설정하는 것이 필요하다. <br/>

### 연동 서비스 이중화
외부 시스템이 100% 가용성을 보장할 수는 없기 때문에, 트래픽이 많은 경우 외부 시스템과의 연동에서 이중화를 고려하는 것도 좋은 방법이다. <br/>
예를 들어, 결제 시스템과 같은 중요한 서비스의 경우, 여러 개의 결제 시스템과 연동하여, 하나의 결제 시스템이 장애가 발생하더라도 다른 결제 시스템을 통해서 결제를 처리할 수 있도록 하는 방식으로 이중화를 구현할 수 있다. <br/>

#### 연동 서비스 이중화 구현 시 고려해야 할 사항들

**1. 장애 감지 및 전환 기준 설정** <br/>
이중화 구현 시에는 장애를 감지한 이후 어떠한 기준으로 트래픽을 다른 시스템으로 전환할 것인지에 대한 기준을 설정하는 것이 중요하다. 
- 장애 감지 기준: 타임아웃, 오류 비율, 응답 시간 등의 지표를 활용하여 장애를 감지
- 전환 기준: 장애 감지 기준을 충족하는 경우, 수동 전환 또는 자동 전환 방식으로 트래픽을 다른 시스템으로 전환하는 방식 설정
  - 자동 전환: 장애 감지 및 전환 기준이 충족되는 경우 자동으로 트래픽을 다른 시스템으로 전환하는 방식, 예를 들어 메시지 시스템의 경우, A 메시지 시스템에서 장애가 발생하는 경우, B 메시지 시스템으로 자동으로 전환하도록 설정
  - 수동 전환: 장애 감지 및 전환 기준이 충족되는 경우 운영자가 수동으로 트래픽을 다른 시스템으로 전환하는 방식, 결제 시스템의 경우, A PG사와 B PG사 모두 서비스를 제공한 이후, A PG사에서 장애가 발생하는 경우 해당 서비스를 일시적으로 중단하는 방식으로 설정 <br/>

특히 서킷 브레이커와 연동하여 장애 감지 기준을 설정한 이후 서킷 브레이커가 Open 상태로 전환되는 경우에 트래픽을 다른 시스템으로 전환하도록 설정하는 것도 좋은 방법이다. <br/>

**2. 외부 시스템 간 스펙 차이 관리** <br/>
이중화를 구현할 때, 동일한 기능을 제공하는 외부 시스템이라 하더라도, API 스펙, 응답 형식, 에러 코드, 요청 제한 등이 다를 수 있다. 이러한 차이를 추상화하여 애플리케이션 코드에서 특정 외부 시스템에 대한 의존성을 줄이는 것이 유지보수 측면에서 좋다. <br/>

**3. 이중화의 트레이드오프 고려**
이중화를 통해서 가용성을 높일 수 있지만, 다양한 외부 시스템을 다뤄야 하기 때문에 아래와 같은 트레이드 오프가 존재한다.
- 외부 시스템간 스펙 차이 관리의 어려움
- 여러 외부 시스템의 관리를 통한 유지보수 및 복잡도 증가
- 비용 증가: 여러 외부 시스템과의 계약 및 사용 비용이 추가로 발생할 수 있다. <br/>

따라서 서비스의 중요도와 장애 발생 시 비즈니스에 미치는 영향을 고려하여 이중화 도입 여부를 판단하는 것이 필요하다.


## 트랜잭션 관리
외부 시스템과의 연동에서 가장 까다로운 문제 중 하나가 트랜잭션 관리이다. 일반적으로 하나의 데이터베이스 내에서의 트랜잭션은 DBMS가 원자성을 보장해 주지만, **_외부 시스템과의 연동이 포함된 작업에서는 하나의 트랜잭션으로 묶을 수 없기 때문에 데이터 정합성 문제가 발생_** 할 수 있다. <br/>
주문 처리 과정에서 결제 시스템과의 연동이 포함된 작업을 예로 들어보자.
- 주문 데이터를 DB에 커밋하였지만 결제 요청이 실패하는 경우, DB에 저장된 주문 데이터는 롤백되지 않기 때문에, 주문 데이터와 결제 데이터 간의 정합성 문제가 발생할 수 있다.
- 결제 요청이 성공하였지만 DB 커밋이 실패하는 경우, 결제는 완료되었지만 주문 데이터가 없는 상태가 발생하여, 주문 데이터와 결제 데이터 간의 정합성 문제가 발생할 수 있다. <br/>

이처럼 외부 시스템과의 연동에서는 **_트랜잭션만으로는 데이터 정합성을 보장하기 어렵기 때문에_**, 이를 해결하기 위한 별도의 전략이 필요하다. <br/>

### 외부 연동과 트랜잭션 관리 시 고려해야 할 사항들

#### 트랜잭션 내에서 외부 호출을 최소화

DB 트랜잭션 내에서 외부 시스템을 호출하는 것은 가능한 피하는 것이 좋다. 외부 시스템 호출이 트랜잭션 내에 포함되면, **_외부 시스템의 응답 시간만큼 트랜잭션이 길어지고, 그동안 DB 커넥션과 락(Lock)을 점유_** 하게 되어 전체 시스템의 성능 저하로 이어질 수 있다. <br/>
따라서 가능하다면 DB 트랜잭션을 먼저 커밋한 후 외부 시스템을 호출하거나, 외부 시스템을 먼저 호출한 후 DB 트랜잭션을 수행하는 방식으로 트랜잭션과 외부 호출을 분리하는 것이 좋다. <br/>
하지만 비즈니스 요구사항에 따라 트랜잭션 내에서 외부 호출을 수행해야 하는 경우도 존재한다. 예를 들어, 결제 요청의 결과에 따라 주문 데이터의 커밋 또는 롤백을 결정해야 하는 경우, 외부 호출이 트랜잭션 내에 포함될 수밖에 없다고 생각할 수 있다. <br/>
이 경우 다음과 같은 문제가 발생할 수 있다.
- 긴 트랜잭션으로 인한 DB 커넥션 점유: 외부 시스템의 응답 시간만큼 트랜잭션이 길어지고, 그동안 DB 커넥션을 점유하게 되어 커넥션 풀이 고갈될 수 있다.
- 락(Lock) 장시간 점유: 트랜잭션 내에서 수정한 행에 대한 락을 외부 호출이 완료될 때까지 유지하게 되어, 동일한 데이터에 접근하는 다른 요청들이 대기하게 된다.
- 타임아웃 시 판단 어려움: 외부 호출에서 타임아웃이 발생한 경우, 외부 시스템이 실제로 요청을 처리했는지 여부를 알 수 없어 커밋/롤백 판단이 어려워진다. <br/>

이러한 문제를 해결하기 위해서 **_상태 기반 처리 패턴_** 을 활용할 수 있다. 상태 기반 처리 패턴이란 **_상태 필드를 활용하여 작업의 진행 상황을 추적하고, 트랜잭션과 외부 호출을 별도의 단계로 분리_** 하는 방식이다. <br/>
예를 들어, 주문과 결제 처리에서 다음과 같은 흐름으로 분리할 수 있다.
1. [트랜잭션 1] 주문 데이터를 저장하고 상태를 "결제 대기(PENDING)"로 설정한 후 커밋
2. [트랜잭션 외부] 결제 API 호출
3. [트랜잭션 2] 결제 결과에 따라 주문 상태를 "완료(COMPLETED)" 또는 "실패(FAILED)"로 변경한 후 커밋

이 방식은 각 트랜잭션의 범위가 짧아지기 때문에 DB 커넥션과 락 점유 시간을 최소화할 수 있다. 또한 "결제 대기(PENDING)" 상태에서 일정 시간 이상 머무르는 주문을 스케줄러를 통해서 감지하여, 결제 상태를 확인하거나 수동으로 처리할 수 있는 대응 방안도 마련할 수 있다. <br/>

#### 외부 호출을 먼저 수행한 후 DB 트랜잭션을 수행하는 방식
외부 시스템을 먼저 호출하고, 그 결과를 기반으로 DB 트랜잭션을 수행하는 방식이다. <br/>
예를 들어 결제 시스템에 결제 요청을 먼저 보낸 후, 결제가 성공하면 DB에 주문 데이터를 저장하는 방식이다. 이 경우 결제 요청이 실패하면 DB 트랜잭션을 수행하지 않기 때문에, 결제 실패로 인한 데이터 정합성 문제를 방지할 수 있다. <br/>
하지만 결제 요청이 성공한 후 DB 커밋이 실패하는 경우, 결제는 완료되었지만 주문 데이터가 저장되지 않는 문제가 발생할 수 있다. 이러한 경우 결제 취소(보상 트랜잭션)를 수행하거나, 실패한 요청을 별도로 저장하여 후속 처리를 하는 등의 대응 방안이 필요하다. <br/>

#### DB 트랜잭션을 먼저 수행한 후 외부 호출을 수행하는 방식 <br/>
DB 트랜잭션을 먼저 커밋한 후 외부 시스템을 호출하는 방식이다. <br/>
예를 들어 DB에 주문 데이터를 먼저 저장한 후, 외부 메시징 시스템에 알림을 보내는 방식이다. 이 경우 DB 트랜잭션이 실패하면 외부 호출을 수행하지 않기 때문에, DB 실패로 인한 데이터 정합성 문제를 방지할 수 있다. <br/>
하지만 DB 커밋이 성공한 후 외부 호출이 실패하는 경우, DB에는 데이터가 저장되었지만 외부 시스템에는 반영되지 않는 문제가 발생할 수 있다. 이러한 경우 재시도 메커니즘을 활용하거나, 실패한 요청을 별도로 저장하여 후속 처리를 하는 등의 대응 방안이 필요하다. <br/>

#### 보상 트랜잭션(Compensation Transaction) <br/>
외부 시스템과의 연동에서 일부 작업이 실패한 경우, 이미 완료된 작업을 되돌리기 위한 작업을 보상 트랜잭션이라고 한다. 즉 강제로 이전 상태로 되돌리는 작업을 의미한다. <br/>
예를 들어 결제가 성공한 후 DB 커밋이 실패한 경우, 결제를 취소하는 API를 호출하여 결제를 되돌리는 것이 보상 트랜잭션에 해당한다. <br/>
보상 트랜잭션을 구현할 때에는 다음과 같은 사항들을 고려해야 한다. <br/>
- 외부 시스템이 보상 트랜잭션을 위한 API를 제공하는지 확인이 필요하다. 예를 들어, 결제 취소 API, 환불 API 등이 제공되어야 보상 트랜잭션을 구현할 수 있다.
- 보상 트랜잭션 자체가 실패할 가능성도 존재한다. 보상 트랜잭션이 실패하는 경우에 대한 재시도 메커니즘이나, 수동으로 처리할 수 있는 절차를 마련해 두는 것이 필요하다.
- 보상 트랜잭션은 원래 작업의 역순으로 수행하는 것이 일반적이다. 예를 들어, A → B → C 순서로 작업이 수행되었다면, C → B → A 순서로 보상 트랜잭션을 수행한다. <br/>

#### 트랜잭셔널 아웃박스 패턴(Transactional Outbox Pattern) <br/>
트랜잭셔널 아웃박스 패턴은 DB 트랜잭션과 외부 시스템으로의 메시지 발행을 하나의 트랜잭션으로 묶기 어려운 문제를 해결하기 위한 패턴이다. <br/>
핵심 아이디어는 **_외부 시스템으로 보내야 할 메시지를 별도의 아웃박스 테이블에 비즈니스 데이터와 동일한 트랜잭션으로 저장_** 하고, 별도의 프로세스가 아웃박스 테이블을 읽어서 외부 시스템으로 메시지를 전달하는 방식이다. <br/>
- 비즈니스 데이터 저장과 아웃박스 메시지 저장이 동일한 DB 트랜잭션으로 처리되기 때문에, 둘 다 성공하거나 둘 다 실패하는 원자성을 보장할 수 있다.
- 별도의 프로세스(스케줄러, CDC 등)가 아웃박스 테이블을 주기적으로 읽어서 외부 시스템으로 메시지를 전달한다.
- 외부 시스템으로의 메시지 전달이 실패하더라도, 아웃박스 테이블에 메시지가 남아있기 때문에 재시도가 가능하다. <br/>

이 패턴은 주로 메시징 시스템(Kafka, RabbitMQ 등)과의 연동에서 자주 사용되며, 비즈니스 데이터 저장과 메시지 발행 간의 데이터 정합성을 보장해야 하는 경우에 효과적이다. <br/>
