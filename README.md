

처리량: 클라이언트 요청에 따라서 서버가 일정 시간 내에 처리할 수 있는 요청의 수
    처리량 = 총 처리된 요청 수 / 총 소요 시간
응답 시간: 사용자가 요청을 보낸 후 응답을 받을 때까지 걸리는 시간 측정
    응답 시간 = 서버 연결 시간 + 서버 처리 시간 + 데이터 전송 시간

해당 두 지표는 시스템의 성능을 평가하는데 중요한 역할을 하기 때문에 모니터링 필요

병목이 발생하는 이유
갑작스럽게 트래픽이 증가하여 서버가 감당할 수 있는 요청량을 초과하는 경우
    트래픽 패턴을 분석하여, 특정 시간대에 스케일업 또는 스케일 아웃 전략 적용
    서버 리소스 사용량이 한계에 도달한 경우, 스케일업 또는 스케일 아웃 전략 적용
응답 시간의 지연으로 인하여 요청을 처리하지 못하는 경우
    커넥션 풀, 스레드 풀 크기 최적화(HTTP, DB 등)
        요청을 
    



- 커넥션 풀이나 스레드 풀 크기 최적화
  - 스레드 풀 크기 조정
    - 프로세스가 처리할 수 있는 동시 스레드 수를 조정 
    - 스레드 풀 크기가 너무 작으면 동시 요청을 처리하지 못해 클라이언트 요청 대기 시간이 증가
    - 스레드 풀 크기가 너무 크면 컨텍스트 스위칭 오버헤드 발생 및 리소스 낭비
    - 적절한 스레드 풀 크기는 I/O 바운드 작업과 CPU 바운드 작업에 따라 다름
      - I/O 바운드 작업의 경우 대부분의 스레드가 I/O 작업을 기다리기 때문에 더 많은 스레드를 허용 가능
      - CPU 바운드 작업의 경우 스레드가 대기하는 시간이 적기 때문에 스레드 수를 CPU 코어 수에 가깝게 설정하는 것이 좋음
    - 스레드 풀 크기 설정 시 고려 사항
      - 서버의 CPU 코어 수
      - 스레드당 메모리 사용량
      - 스레드 평균 처리 시간
      - 애플리케이션의 특성(I/O 바운드 vs CPU 바운드)
      - 스레드 상태 분포
        - 스레드가 주로 대기 상태인지, 실행 상태인지 분석
        - 대기 상태가 많다면 스레드 풀 크기를 늘리는 것이 도움이 될 수 있음
      - 최소 및 최대 스레드 수 설정
        - 최소 스레드 수: 스레드 풀이 유지하는 최소 스레드 수
        - 최대 스레드 수: 스레드 풀이 허용하는 최대 스레드 수
      - 스레드 대기열 크기 설정
        - 최소 스레드 수가 모두 사용 중일 때, 추가 요청을 대기시키는 대기열 크기 설정
        - 대기열 크기가 너무 크면, 최소 스레드 수만큼 요청을 처리하게 되어 응답시간이 증가할 수 있음
        - 대기열 크기가 너무 작으면, 요청된 작업이 거부될 수 있음
        - 최소 스레드수와 최대 스레드 수를 동일하게 설정하는 방법도 있음
  - 커넥션 풀 크기 조정
    - 응답 시간에는 커넥션을 맺고 해제하는 시간이 포함되어 있기 때문에 커넥션을 미리 생성하고 재사용하는 커넥션 풀이 필요
    - 스레드 풀의 크기가 커도 커넥션 풀의 크기가 작으면 동시 요청을 처리하지 못해 클라이언트 요청 대기 시간이 증가
    - HTTP, DB등 다양한 커넥션 풀에 대해 적절한 크기 설정할 필요성 있음
      - 커넥션 풀 크기가 너무 작으면 동시 요청을 처리하지 못해 대기 시간이 증가
      - 커넥션 풀 크기가 너무 크면 요청 서버의 리소스 낭비 및 오버헤드 발생
      - 때문에 요청 서버의 동시 처리 가능 커넥션 수, 리소스 사용량 등을 고려하여 적절한 커넥션 풀 크기 설정 필요
    - 요청을 받는 DB나 외부 서비스의 상태 및 최대 커넥션 수 제한 고려할 것
    - 커넥션 풀 설정 시 고려 사항
      - 요청 서버의 최대 동시 처리 가능 커넥션 수
      - 요청 서버의 리소스 사용량
      - 요청 서버의 커넥션 유지 시간
        - `커넥션 풀의 최대 유지 사간 < 요청 서버의 커넥션 유지 시간` 으로 설정
        - 안그러면 요청 서버에서 커넥션이 강제로 종료되어, 애플리케이션에서 해당 커넥션에 접근 시 예외 발생
      - Connection Timeout 설정
        - 커넥션을 맺는 데 걸리는 최대 시간 설정
        - 만약 설정된 시간 내에 커넥션이 맺어지지 않으면, 타임아웃으로 간주하고 예외 처리
      - Read/Write Timeout 설정
        - 커넥션이 맺어진 후, 읽기/쓰기 작업이 완료되는 데 걸리는 최대 시간 설정
        - 만약 설정된 시간 내에 작업이 완료되지 않으면, 타임아웃으로 간주하고 예외 처리
      - 최소 커넥션 수 및 최대 커넥션 수 설정
        - 최소 커넥션 수: 커넥션 풀에서 유지하는 최소 커넥션 수
        - 최대 커넥션 수: 커넥션 풀에서 허용하는 최대 커넥션 수
        - 최소 커넥션 수와 최대 커넥션 수를 동일하게 설정하는 방법도 있음
    - 최대 유휴 시간 
      - 커넥션이 일정 시간 사용되지 않으면 자동으로 종료되도록 설정하여 리소스 낭비 방지
    - 최대 유지 시간
      - 커넥션이 일정 시간 이상 유지되지 않도록 설정하여 오래된 커넥션으로 인한 문제 방지 
    - 커넥션 유효성 검사
      - 커넥션이 유효한지 주기적으로 검사하여, 유효하지 않은 커넥션을 제거하고 새로운 커넥션 생성
  


- 캐싱을 통한 읽기 성능 향상
  - CDN 사용을 통한 정적 자원 제공 속도 향상
  - 리모트 캐시 도입을 통한 응답 시간 단축, Redis, Memcached 와 같은 인메모리 데이터 저장소 활용
  - 로컬 캐시 활용
    - 캐싱 DB를 도입하기 어려운 경우 or 캐싱 DB 커넥션 비용이 큰 경우
  - 대부분 Look-Aside 전략을 많이 활용(캐시 미스 시 DB 조회, 이후 캐시 적재하여 다음 요청부터 캐시 조회)
  - 캐시 미스를 최소화 하기 위하여 캐시 웜업 전략 활용
    - 배치를 통해 자주 조회되는 데이터를 미리 캐시에 적재
    - 애플리케이션이 시작될 때 자주 조회되는 데이터를 미리 캐시에 적재, 주로 애플리케이션 초기화 시점에 수행
  - 캐싱을 통한 읽기 성능 향상시에는 일관성 문제에 대한 고려 필요
    - 일관성이 크게 요구 되지 않는 경우
      - TTL(Time To Live) 설정을 통한 캐시 만료 정책 수립
      - 배치 작업을 통해 주기적으로 캐시 갱신
    - 일관성이 크게 요구 되는 경우
      - 원본 데이터 변경과 캐시 데이터 갱신 작업을 동일 트랜잭션으로 관리하여 실시간으로 일관성 유지
      - 메시징 서비스나 비동기를 이용하여 캐시 갱신 작업을 거의 실시간으로 처리

### 쓰기 지연




